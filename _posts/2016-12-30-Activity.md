---
layout: post
comments: true
title: "Activity"
date: 2016-12-30
categories: android
tags: [android]
---

> An activity is a single, focused thing that the user can do.

## 生命周期

![complete_android_fragment_lifecycle](https://ww2.sinaimg.cn/large/006tNc79gw1fbacu07z8kj30x81ywwnl.jpg)

### 系统资源的释放

一般将系统资源的释放放在onPause中，比如Camera、Sensor、Receivers



## 启动模式

### Activity启动模式

* lunchMode
  * standard
  * singleTop
  * singleTask
    * 检查当前栈中是否存在需要启动的Activity, 清理栈顶直到此Activity位于栈顶
  * singleInstance
    * 会出现在一个新的任务栈中，且此任务栈中只存在这一个Activity
    * 此新的任务栈可被多个应用共享
    * 应用于需要与程序分离的界面，如调用紧急呼叫，就是使用这种启动模式
* clearTaskOnLaunch
  * **只对根Activity生效**
  * 每次返回该TASK，都会将该TASK之上的所有其他Activity清除
* finishOnTaskLaunch
  * 当用户离开这个TASK，再返回的时候，该Activity就会被finish掉
* alwaysRetainTaskState
  * **只对根Activity生效**
  * 所在的TASK栈不接受任何清理命令，一直保持Task状态
* allowTaskReparenting
  * 在应用推到后台时，能否从启动它的哪个Task移动到具有公共affinity的task
  * 比如app启动了web浏览器的一个Activity,这个activity此时在app的task上，当app退到后台再进入前台，会发现这个activity已经到了浏览器应用的task中了

### IntentFlag启动模式

* NEW_TASK
  * Service因为不依附任何栈，所以若从Service中创建新的Activity需要使用此方法
* SINGLE_TOP
  * 同single_top
* CLEAR_TOP
  * 同single_task
* NO_HISTORY
  * 该Activity启动其他Activity后，就消失了

### Android任务栈

> Android任务栈被称为一个TASK,一个TASK中的Activity可以来自不同的APP，同一个App的Activity也可能不在一个Task中

* 不同TASK栈之间**不能传递数据**，只能由Intent传递
  * 比如调用startActivityForResult启动一个SingleInstance模式的Activity,会立即返回Activity.RESULT_CANCELED

  ​

## 内存重启

**原则** View的记录信息由View记录，Fragment的记录信息由Fragment记录。

* intent中的信息会被自动保存
* 其他需要持久化保存的信息需要在onSavedInstantceState()中保存

故而带Fragment的Activity的建议写法为

```Java
public class ActivityWithFragment{
  	@Override
  	@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.XXX);

        Fragment fragment = getSupportFragmentManager().findFragmentById(R.id.contentFrame);
        if (fragment == null) {
            // Create the fragment
            fragment = TasksFragment.newInstance();
            ActivityUtils.addFragmentToActivity(
                    getSupportFragmentManager(), fragment, R.id.contentFrame);
        }


        // Load previously saved state, if available.
        if (savedInstanceState != null) {
            TasksFilterType currentFiltering =
                    (TasksFilterType) savedInstanceState.getSerializable(CURRENT_FILTERING_KEY);
            mTasksPresenter.setFiltering(currentFiltering);
        }
    }
}
```


## 横竖屏切换

### 横竖屏切换时Activity的生命周期 ###

1、默认情况下，切屏会重新调用各个生命周期

2、设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法（3.2之前还是会调用各个生命周期）

如果横竖屏的界面布局不同，可以在res下新建layout-land和layout-port目录，然后把布局文件扔到这两个目录文件中

#### Configuration ####
描述了设备的所有配置信息，会影响到应用程序检索的资源。包括了用户指定的选项(locale和scaling)，也包括设备本身的配置(例如input modes,screen size and screen orientation)，可以在该类里查看所有影响Configuration Change的属性

常见的银发Configuration Change的属性：
- 横竖屏切换
    - android:configChanges="orientation"
- 键盘可用性
    - android:configChanges="keyboardHidden"
- 屏幕大小变化
    - android:configChanges="screenSize"
- 语言的更改
    - android:configChanges="locale"

### 可能引发的问题 ###

#### 重走生命流程

界面中用户选择了checkbox和radiobutton选项或者通过网络请求显示在界面上的数据在屏幕旋转后Activity被destroy-recreate，这些空间上被选择的状态和界面上的数据都会消失。

进入某个Activity时加载页面进行网络请求，此时旋转屏幕会重新创建网络请求，这样的用户体验非常不好。

伴随异步操作显示一个progressDialog的话，异步任务未完成去旋转屏幕，程序会因为Activity has leaked window而终止。而当old activity被销毁后，线程执行完毕后还是会把结果返回给old activity而非新的activity

建议要override onSaveInstanceState()方法

#### onConfigChange()

在onConfigChange()中**获取不到新的Layout和控件的尺寸位置信息**，必须通过消息异步或者延时调用

不可以动态加载xml，可能会有很多硬代码



## Activity过渡动画

### 提供了三种Transition类型

- 进入
  - 决定Activity中的所有的视图怎么进入屏幕
- 退出
  - 决定一个Activity中的所有视图怎么退出屏幕
- 共享元素
  - 决定两个Activities之间的过渡，怎么共享他们的视图

#### 进入、退出

- explode
  - 从屏幕中间进或出，移动视图
- slide
  - 滑动，从屏幕边缘进或出，移动视图
- fade
  - 淡出，通过改变屏幕上的视图的不透明度达到添加或者移除视图

#### 共享元素

- changeBounds
  - 改变目标视图的布局边界
- changeClipBounds
  - 裁剪目标视图边界
- changeTransform
  - 改变目标视图的缩放比例和旋转角度
- changeImageTransform
  - 改变目标图片的大小和缩放比例

### 代码

#### 普通动画

```java
//ActivityA
startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle());

//ActivityB先声明后设置
A在代码中声明
getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);
B在xml中声明
<item name="android:windowContentTransitions">true</item>

具体设置:
getWindow().setEnterTransition(new Explode());
getWindow().setExitTransition(new Slide());
```

#### 淡出效果

```java
在ActivityA和ActivityB中同时定义
android:transitionName="XXX"

如果只需要一个共享元素，可以在ActivityA中：
startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this,view,"share").toBundle());

如果需要多个共享元素
startActivity(intent,
    ActivityOptions.makeSceneTransitionAnimation(
        this,
        Pair.Create(view,"share"),Pair.create(fab,"fab")
    ).toBundle()
);
```

#### 定义在Theme中

```
<style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
    <!-- Customize your theme here. -->
    <item name="android:windowAnimationStyle">@style/ActivityAnimTheme</item>
</style>

<style name="ActivityAnimTheme" parent="@android:style/Animation.Activity">
    <item name="android:activityOpenEnterAnimation">@anim/activity_right_in</item>
    <item name="android:activityOpenExitAnimation">@anim/activity_right_out</item>
    <item name="android:activityCloseEnterAnimation">@anim/activity_right_in</item>
    <item name="android:activityCloseExitAnimation">@anim/activity_right_out</item>
</style>

//下面是xml的sample
<?xml version="1.0" encoding="utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android">
<translate
    android:duration="500"
    android:fromXDelta="100%"
    android:fromYDelta="0"
    android:interpolator="@android:anim/accelerate_decelerate_interpolator"
    android:toXDelta="0%"
    android:toYDelta="0" />
</set>
```