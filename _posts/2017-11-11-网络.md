---
layout: post
comments: true
title: "网络相关"
date: 2017-11-11
categories: network
tags: [network]
---

# 网络

## URI

Uniform Resource identifier

统一资源标识符，用来唯一的标志一个**资源**

File://a:1234/b/c/d.txt

*   访问资源的命名机制
*   主机名
*   资源自身的名称，由路径展示

## URL

Universal Resource Locator

统一资源定位器，是一种**具体的URI**

可以用来标志一个资源，还指明了如何locate这个资源

*   协议
*   存有该资源的主机IP地址
*   主机资源具体地址

## 分层

* 应用层
  * 收到传输层数据后按格式进行解读
  * HTTP、FTP、Telnet、SMTP、POP3
* 传输层
  * 建立主机到主机的通信，为两台主机上的应用提供端到端的通信
  * TCP UDP
* 网络层
  * 决定如何将数据从发送方路由到接收方
  * 综合考虑发送优先权、网络拥塞程度、服务质量、可选路由的花费
  * ip协议
* 数据链路层
  * 从网络层接收到的数据被分割成特定的可被物理层传输的帧
  * 原始数据、发送方和接收方的物理地址、纠错和控制信息
* 物理层

# HTTP

是面向对象协议，使用于分布式超媒体信息系统。

* 支持CS模式
* 简单快速
* 灵活，允许传输任意类型的数据
* **无连接**，限制每次连接只处理一个请求
* **无状态**，对于事务处理没有记忆能力

## URL格式

```
http://host[":"port][abs_path]
```

## Cookie和Session

### Cookie

是**客户端**的解决方案（HTTP是无状态的），是服务器发给客户端的特殊信息，这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。

![1510379800835](https://ws1.sinaimg.cn/large/006tKfTcgy1fle3tlox07j30kw0acwez.jpg)

### Session

保存在**服务器**上。客户端浏览器访问Server的时候，Server把客户端信息以某种形式记录在服务器上。

## 请求报文

![requestHttp](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1507393085215&di=31c995f6e06cee71486a2e79fecf4f23&imgtype=0&src=http%3A%2F%2Froclinux.cn%2Fwp-content%2Fuploads%2F2013%2F12%2FHTTP%25E5%258D%258F%25E8%25AE%25AE-%25E8%25AF%25B7%25E6%25B1%2582%25E6%258A%25A5%25E6%2596%2587%25E6%25A0%25BC%25E5%25BC%258F.png)

* 请求行
* 请求报头
* 请求数据

### 请求行

Method Request-URI HTTP-VERSION CRLF

> GET http://blog.csdn.net/ HTTP/1.1

八种请求方法：

* GET
  * 请求获取Request-URI所标识的资源
  * 大小有限制
* POST
  * 在Request-URI所标识的资源后附加新的数据
  * 数据放在body中，无大小限制
* HEAD
  * 请求获取由URI所标志的资源的响应消息报头
* PUT
  * 请求服务器存储一个资源，并用URI作为其标识
* DELETE
  * 请求服务器删除URI所标识的资源
* TRACE
  * 请求服务器回送收到的请求信息，主要用于测试或诊断
* CONNECT
  * 预留给能够将连接改为管道方式的代理服务器
* OPTIONS
  * 能够查询服务器的性能

## 响应报文

![responseHTTP](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1507393435182&di=a151b5ba1fa56eb7a8964ee0297fcc5e&imgtype=0&src=http%3A%2F%2Froclinux.cn%2Fwp-content%2Fuploads%2F2013%2F12%2FHTTP%25E5%258D%258F%25E8%25AE%25AE-%25E5%2593%258D%25E5%25BA%2594%25E6%258A%25A5%25E6%2596%2587%25E6%25A0%25BC%25E5%25BC%258F1.png)

* 状态行
* 响应报头
* 空行

### 状态行

HTTP-Version Status-Code Reason-phrase CRLF

> HTTP/1.1 200 OK

* 100~199
  * 收到请求，需要请求者继续执行操作
* 200~299
  * 请求成功，请求已被成功接收并处理
  * 200 OK
* 300~399
  * 重定向，要完成请求必须进行更进一步的操作
* 400~499
  * 客户端错误，请求有语法错误或请求无法实现
  * 400 Bad Request
  * 401 Unauthorized
  * 403 Forbidden
* 500~599
  * 服务器错误，服务器不能实现合法的请求
  * 500 Internal Server Error
  * 503 Server Unavailable

## 消息报头

### 通用部分

* Date
* Connection
* Cache-Control

### 请求报头

* Host
  * 请求主机名
* User-Agent
  * 发送请求的浏览器类型
* Accept
  * 指定客户端接收哪些类型的信息
  * 比如*/*
* Refer
  * 从哪个链接链接过来的
* Accept-Encoding
  * 客户端可识别的数据编码
* Accept-Language
  * 浏览器支持的语言类型
* Connection
  * 允许客户端和服务器指定与请求、响应连接有关的选项
  * 如Keep-Alive
* if-none-match
  * 缓存
  * 返回304，直接使用本地缓存
* If-modified-since
  * 返回304，直接使用本地缓存


* Transfer-Encoding
  * 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式

### 响应报头

* Location
  * 用于重定向接收者到一个新的位置
* Server
  * 包含服务器用来处理请求的系统信息
* ETag
  * 标志服务端信息的标志位
  * 和if-none-match配对
* Expires
  * 缓存时间控制
* Cache-Control
* Proxy-Connection
  * keep-alive

### 实体报头

* Content-Type
  * 发送给接收者的实体正文的媒体类型
* Content-Length
  * 实体正文的长度
* Content-Language
* Content-Encoding
* Last-Modified
  * 指示资源的最后修改时间和日期
* Expires
  * 响应过期的日期和时间

## HTTP 1.X 协议存在的问题

*   传输数据时，每次都要重新建立链接
*   所有传输内容都是明文，客户端和服务器无法验证对方身份
*   header里携带的内容过大，在一定程度上增加了传输成本
*   虽然支持keep-alive，来弥补多次创建连接产生的延迟，但是使用多了同样会给服务器带来大量的性能压力

# HTTPS

## HTTPS

不是一个单独的协议，是对工作在加密连接（SSL/TLS）上的常规HTTP协议。

通过在TCP和HTTP之间加入TLS来加密。

## SSL/TLS

SSL协议是一种安全传输协议。

![1510380517163](https://ws4.sinaimg.cn/large/006tKfTcgy1fle45c3xxcj30yy0ja0uv.jpg)

### TCP和UDP

| TCP           | UDP       |
| ------------- | --------- |
| 基于连接，全双工的可靠信道 | 无连接，不可靠信道 |
| 要求系统资源较多      | 较少        |
| 流模式           | 数据报模式     |
| 保证数据正确性       | 可能丢包      |
| 保证数据顺序        | 不保证       |
| 文件传输、重要状态的更新  | 视频传输、实时通信 |
|               |           |
|               |           |
|               |           |



# Android中的网络通信框架

## HttpURLConnection

API简单，体积较小，适应于Android项目，而且其压缩和缓存机制可以有效的减少网络访问的流量。

### GET

```java
URL mURL = new URL(url);
httpURLConnection = (HttpURLConnection) mURL.openConnection();
httpURLConnection.setConnectTimeout(15000);
httpURLConnection.setReadTimeout(15000);
httpURLConnection.setRequestMethod("GET");
httpURLConnection.setRequestProperty("Connection", "Keep-Alive");
httpURLConnection.setDoInput(true);
httpURLConnection.connect();

inputStream = httpURLConnection.getInputStream();
int code = httpURLConnection.getResponseCode();
String response = UrlConnManager.convertStreamToString(inputStream);
inputStream.close();
```

### POST

```java
URL mURL = new URL(url);
httpURLConnection = (HttpURLConnection) mURL.openConnection();

httpURLConnection.setConnectTimeout(15000);
httpURLConnection.setReadTimeout(15000);
httpURLConnection.setRequestMethod("POST");
httpURLConnection.setRequestProperty("Connection", "Keep-Alive");
httpURLConnection.setDoInput(true);
//post传递参数时需要开启
httpURLConnection.setDoOutput(true);

//post body
OutputStream outputStream = httpURLConnection.getOutputStream();
StringBuilder sb = new StringBuilder();
for (NameValuePair nameValuePair : paramsList) {
    if (!TextUtils.isEmpty(sb)) {
        sb.append("&");
    }
    sb.append(URLEncoder.encode(nameValuePair.getName(), "UTF-8"));
    sb.append("=");
    sb.append(URLEncoder.encode(nameValuePair.getValue(), "UTF-8"));
}
BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8"));
writer.write(sb.toString());
writer.flush();
writer.close();

httpURLConnection.connect();
inputStream = httpURLConnection.getInputStream();
int code = httpURLConnection.getResponseCode();
String response = UrlConnManager.convertStreamToString(inputStream);
inputStream.close();
```

## Volley

适合进行数据量不大但通信频繁的网络操作

对于大数据量的网络操作，比如下载文件等，表现就比较糟糕。

基于HttpURLConnection。

基于队列，有四个NetworkDispatcher，一个CacheDispatcher。

1.  创建RequestQueue


2.  创建XXRequest
3.  RequestQueue#add

```Java
RequestQueue queue = Volley.newRequestQueue(getApplicationContext());
StringRequest stringRequest = new StringRequest(
    Request.Method.GET,
    "https://www.baidu.com",
    new Response.Listener<String>() {
        @Override
        public void onResponse(String response) {
            Log.d(TAG, "====" + response);
         }
    },
    new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
        }
    }
);
JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(
    "http://ip.taobao.com/service/getIpInfo.php?ip=59.108.54.37",
    null,
    new Response.Listener<JSONObject>() {
        @Override
        public void onResponse(JSONObject response) {
             IpModel ipModel = new Gson().fromJson(response.toString(), IpModel.class);
             Log.d(TAG, "====ip" + ipModel);
        }
    },
    new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {

        }
    }
);
queue.add(stringRequest);
queue.add(jsonObjectRequest);
```



## OKHttp

会从很多常用的连接问题中自动恢复，比如服务器配置了多个IP，当第一个IP连接失败时，会自动尝试下一个IP。（原理是通过拦截器进行实现）

Fresco、Glide、Picasso、Retrofit都使用了OkHttp

使用方法：

1.  通过RequestBuilder创建Request
2.  创建OkHttpClient
3.  通过OkHttpClient#newCall(Request)创建Call
4.  调用Call#enqueue或execute

```java
okhttp3.Request.Builder requestBuilder = new okhttp3.Request.Builder().url("http://blog.csdn.net/itachi85");
//POST请求需要用FormBody封装请求的参数
requestBuilder.method("GET", null);
okhttp3.Request request = requestBuilder.build();

OkHttpClient okHttpClient = new OkHttpClient();
Call call = okHttpClient.newCall(request);

call.enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {

    }

    @Override
    public void onResponse(Call call, okhttp3.Response response) throws IOException {
        Log.d(TAG, "====" + response.body().toString());
    }
});
```

## Retrofit

底层是基于OkHttp实现的。

与其他框架不同的是，更多使用运行时注解的方式提供功能。

使用方法：

1.  创建Retrofit
2.  使用Retrofit创建对应的接口，使用接口返回Call
3.  Call#enqueue或者execute

```java
//POST
public interface IpServiceForPost {
    @FormUrlEncoded
    @POST("{path}/getIpInfo.php")
    Call<IpModel> getIpMsg(@Path("path") String path, @Field("ip") String first);
}

//GET
public interface IpService {
    @GET("{path}/getIpInfo.php")
    Call<IpModel> getIpMsg(@Path("path") String path, @Query("ip") String ip);
}

//其他注解
//Path：地址
//Query(Map)
//Field
//Body 数据传输类型JSON字符串
//Part 单个文件上传
//Header 消息报头


String url = "http://ip.taobao.com/";
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(url)
    .addConverterFactory(GsonConverterFactory.create())
    .build();
IpService ipService = retrofit.create(IpService.class);
retrofit2.Call<IpModel> call = ipService.getIpMsg("service","59.108.54.37");

// 同步方法使用execute
call.enqueue(new retrofit2.Callback<IpModel>() {
    @Override
    public void onResponse(retrofit2.Call<IpModel> call, retrofit2.Response<IpModel> response) {
        String country = response.body().toString();
        Log.d(TAG, "==== coutry is " + country);
    }

        @Override
        public void onFailure(retrofit2.Call<IpModel> call, Throwable t) {

        }
});
```
