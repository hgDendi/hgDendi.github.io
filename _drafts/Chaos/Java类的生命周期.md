# Java类的生命周期 #


## 重要内存区域 ##

- 方法区

>已经加载的类信息、常量、静态变量以及方法代码的内存区域
- 常量池

>常量和类中的符号引用
- 堆区

对象实例
- 栈区

>由一个一个的栈帧组成的栈式结构,栈帧包含:方法运行时产生的局部变量、方法出口等信息。

## 类的生命周期 ##

1. Loading 加载

>找到需要加载的类并把类的信息加载到方法区中，然后在堆区中实例化一个Class对象，作为方法区中这个类的信息的入口


2. Linking 连接

>不一定要等到加载完成后，有时可以同时执行

>→验证  验证类的合法性


>→准备  为类的静态变量分配内存并设为JVM默认的初值，对于非静态变量，则不会为其分配内存。注意此时的初值是系统默认，不是用户定义的。


>→解析  将常量池中的符号引用转换为直接引用


3. Initialization 初始化

>如果一个类被直接引用，就会触发类的初始化
>
- 通过new实例化、读取或设置类的静态变量、调用类的静态方法
- 通过反射方式执行上面三种方法
- 初始化子类时，会触发父类
- 程序入口直接运行时，调用main方法时


>其他引用为被动引用，不会触发初始化。

>只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行


4. Using 使用

>讲一下类的被动引用
>
- 引用父类的静态字段，只会引起父类的初始化，不会引起子类的初始化
- 定义类数组，不会引起类的初始化
- 引用类的常量，不会引起类的初始化

5. Unloading 卸载

>满足下面的情况，类就会被卸载
>


- 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有任何地方呗引用，无法再任何地方通过反射访问该类的方法