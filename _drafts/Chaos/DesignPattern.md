# Design Pattern #

## Open Close Principle ##
开闭原则

Software entities should be open for extension,but closed for modification

软件模块应该对扩展开放，对修改关闭

## Liskov Substitution Principle ##
里氏代换原则

只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为

## Dependence Inversion Principle ##
依赖倒转原则

针对接口编程，而不是针对实现编程

## Interface Segregation Principle ##
接口隔离原则

使用多个隔离的接口，比使用单个接口要好

## Demeter Principle ##
迪米特法则

一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立

## Single responsibility principle ##
单一职责原则

一个类只负责一个功能领域中的相应职责，或者可以定义为，就一个类而言，应该只有一个引起它变化的原因

# 原则

- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
- 多用组合，少用继承
- 针对接口编程，而不是针对实现编程
- 为了交互对象之间的松耦合设计而努力
- 类应该对扩展开放，对修改关闭（在不改变现有代码的情况下，搭配新的行为）
- 要依赖抽象，不要依赖具体类（当你直接实例化一个对象时，就是在依赖它的具体类）
  - 变量不可以持有具体类的引用
  - 不要让类派生自具体类
  - 不要覆盖基类中已实现的方法
- LeastKnowledge Principle
  - 只和你的密友交谈
- 好莱坞原则
  - 别调用我们，我们调用你
- 一个类应该只有一个引起变化的原因

## 策略模式

> 定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

## Observer Pattern

> 在对象之间定义一对多的依赖，这样依赖，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新

如AddOnClickListener

## 装饰模式

> 在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的 

> 动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案

> 装饰者和被装饰者必须是一样的类型，这里利用继承达到“类型匹配”，而不是利用继承获得“行为”

如BufferedInputStream FileInputStream

## Factory Pattern

> 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

## Singleton Pattern

> 确保一个类只有一个实例，并提供一个全局访问点

## 命令模式

> 将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。

## Adapter Pattern

> 将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间                                                                                                                                                                                                                                                                                      

## Facade Pattern

> 提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。

## 模板方法

> 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

钩子：被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩

## 迭代器与组合模式

> 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

## 组合模式Composite

> 允许你将对象组合成树形结构来表现“整体、部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合

## 状态模式

> 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类

## 代理模式

> 为另一个对象提供一个替身或占位符以控制对这个对象的访问

> 使用代理模式创建对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象

- Firewal Proxy
  - 控制网络资源的访问，保护主题免于“坏客户”的侵害
- Smart Reference Proxy
  - 当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数
- Caching Proxy
  - 为开销大的计算结果提供暂时的存储：它也允许多个客户共享结果，以减少计算或网络延迟
- Synchronization Proxy
  - 在多线程的情况下为主题提供安全的访问
- Complexity Hiding Proxy
  - 用来影藏一个类的复杂集合的复杂度，并进行访问控制。有时候也成为外观代理，这不难理解。
  - 代理控制访问，而外观模式只提供另一组接口
- Copy-On-Write Proxy
  - 用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止。

## Compound Pattern复合模式

> 在一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题

## 反模式

## 桥接模式

> 通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变

## Builder Pattern

> 封装一个产品的构造过程，并允许按步骤构造

## 责任链 Chain of Responsibility Pattern

> 为某个请求创建一个对象链，每个对象依序检查此请求，并对其进行处理，或者将它传递给链中的下一个对象

## 蝇量 Flyweight Pattern

> 想让某个类的一个实例能用来提供许多“虚拟实例”

## 解释器 Interpreter Pattern

## 中介者 Mediator Pattern

> 集中相关对象之间复杂的沟通和控制方式

## 备忘录 MementoPattern

## 原型 Prototype Pattern

> 当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式

> 通过复制现有的实例来创建新的实例，在Java中，通常意味着使用clone方法或者反序列化

## 访问者模式 Visitor Pattern

> 想要为一个对象的组合增加新的能力，且封装并不重要时

