# 网络

## 分层

* 应用层
  * 收到传输层数据后按格式进行解读
  * HTTP、FTP、Telnet、SMTP、POP3
* 传输层
  * 建立主机到主机的通信，为两台主机上的应用提供端到端的通信
  * TCP UDP
* 网络层
  * 决定如何将数据从发送方路由到接收方
  * 综合考虑发送优先权、网络拥塞程度、服务质量、可选路由的花费
* 数据链路层
  * 从网络层接收到的数据被分割成特定的可被物理层传输的帧
  * 原始数据、发送方和接收方的物理地址、纠错和控制信息
* 物理层

## HTTP

是面向对象协议，使用于分布式超媒体信息系统。

* 支持CS模式
* 简单快速
* 灵活，允许传输任意类型的数据
* 无连接，限制每次连接只处理一个请求
* 无状态，对于事务处理没有记忆能力

### URL格式

```
http://host[":"port][abs_path]
```

### 请求报文

![requestHttp](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1507393085215&di=31c995f6e06cee71486a2e79fecf4f23&imgtype=0&src=http%3A%2F%2Froclinux.cn%2Fwp-content%2Fuploads%2F2013%2F12%2FHTTP%25E5%258D%258F%25E8%25AE%25AE-%25E8%25AF%25B7%25E6%25B1%2582%25E6%258A%25A5%25E6%2596%2587%25E6%25A0%25BC%25E5%25BC%258F.png)

* 请求行
* 请求报头
* 请求数据

#### 请求行

Method Request-URI HTTP-VERSION CRLF

> GET http://blog.csdn.net/ HTTP/1.1

八种请求方法：

* GET
  * 请求获取Request-URI所标识的资源
* POST
  * 在Request-URI所标识的资源后附加新的数据
* HEAD
  * 请求获取犹URI所标志的资源的响应消息报头
* PUT
  * 请求服务器存储一个资源，并用URI作为其标识
* DELETE
  * 请求服务器删除URI所标识的资源
* TRACE
  * 请求服务器回送收到的请求信息，主要用于测试或诊断
* CONNECT
  * 预留给能够将连接改为管道方式的代理服务器
* OPTIONS
  * 能够查询服务器的性能

### 响应报文

![responseHTTP](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1507393435182&di=a151b5ba1fa56eb7a8964ee0297fcc5e&imgtype=0&src=http%3A%2F%2Froclinux.cn%2Fwp-content%2Fuploads%2F2013%2F12%2FHTTP%25E5%258D%258F%25E8%25AE%25AE-%25E5%2593%258D%25E5%25BA%2594%25E6%258A%25A5%25E6%2596%2587%25E6%25A0%25BC%25E5%25BC%258F1.png)

* 状态行
* 响应报头
* 空行

#### 状态行

HTTP-Version Status-Code Reson-phrase CRLF

> HTTP/1.1 200 OK

* 100~199
  * 收到请求，需要请求者继续执行操作
* 200~299
  * 请求成功，请求已被成功接收并处理
  * 200 OK
* 300~399
  * 重定向，要完成请求必须进行更进一步的操作
* 400~499
  * 客户端错误，请求有语法错误或请求无法实现
  * 400 Bad Request
  * 401 Unauthorized
  * 403 Forbidden
* 500~599
  * 服务器错误，服务器不能实现合法的请求
  * 500 Internal Server Error
  * 503 Server Unavailable

### 消息报头

#### 通用部分

* Date
* Connection
* Cache-Control

#### 请求报头

* Host
  * 请求主机名
* User-Agent
  * 发送请求的浏览器类型
* Accept
  * 指定客户端接收哪些类型的信息
* Accept-Encoding
  * 客户端可识别的数据编码
* Accept-Language
  * 浏览器支持的语言类型
* Connection
  * 允许客户端和服务器指定与请求、响应连接有关的选项
  * 如Keep-Alive
* Transfer-Encoding
  * 告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式

#### 响应报头

* Location
  * 用于重定向接收者到一个新的位置
* Server
  * 包含服务器用来处理请求的系统信息

#### 实体报头

* Content-Type
  * 发送给接收者的实体正文的媒体类型
* Content-Length
  * 实体正文的长度
* Content-Language
* Content-Encoding
* Last-Modified
  * 指示资源的最后修改时间和日期
* Expires
  * 响应过期的日期和时间

## HttpURLConnection

API简单，体积较小，适应于Android项目，而且其压缩和缓存机制可以有效的减少网络访问的流量。

### GET

```java
URL mURL = new URL(url);
httpURLConnection = (HttpURLConnection) mURL.openConnection();
httpURLConnection.setConnectTimeout(15000);
httpURLConnection.setReadTimeout(15000);
httpURLConnection.setRequestMethod("GET");
httpURLConnection.setRequestProperty("Connection", "Keep-Alive");
httpURLConnection.setDoInput(true);
httpURLConnection.connect();
inputStream = httpURLConnection.getInputStream();
int code = httpURLConnection.getResponseCode();
String response = UrlConnManager.convertStreamToString(inputStream);
inputStream.close();
```

### POST

```java
URL mURL = new URL(url);
httpURLConnection = (HttpURLConnection) mURL.openConnection();

httpURLConnection.setConnectTimeout(15000);
httpURLConnection.setReadTimeout(15000);
httpURLConnection.setRequestMethod("POST");
httpURLConnection.setRequestProperty("Connection", "Keep-Alive");
httpURLConnection.setDoInput(true);
//post传递参数时需要开启
httpURLConnection.setDoOutput(true);

//post body
OutputStream outputStream = httpURLConnection.getOutputStream();
StringBuilder sb = new StringBuilder();
for (NameValuePair nameValuePair : paramsList) {
    if (!TextUtils.isEmpty(sb)) {
        sb.append("&");
    }
    sb.append(URLEncoder.encode(nameValuePair.getName(), "UTF-8"));
    sb.append("=");
    sb.append(URLEncoder.encode(nameValuePair.getValue(), "UTF-8"));
}
BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8"));
writer.write(sb.toString());
writer.flush();
writer.close();

httpURLConnection.connect();
inputStream = httpURLConnection.getInputStream();
int code = httpURLConnection.getResponseCode();
String response = UrlConnManager.convertStreamToString(inputStream);
inputStream.close();
```

## Volley

适合进行数据量不大但通信频繁的网络操作

```Java
RequestQueue queue = Volley.newRequestQueue(getApplicationContext());
StringRequest stringRequest = new StringRequest(
    Request.Method.GET,
    "https://www.baidu.com",
    new Response.Listener<String>() {
        @Override
        public void onResponse(String response) {
            Log.d(TAG, "====" + response);
         }
    },
    new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
        }
    }
);
JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(
    "http://ip.taobao.com/service/getIpInfo.php?ip=59.108.54.37",
    null,
    new Response.Listener<JSONObject>() {
        @Override
        public void onResponse(JSONObject response) {
             IpModel ipModel = new Gson().fromJson(response.toString(), IpModel.class);
             Log.d(TAG, "====ip" + ipModel);
        }
    },
    new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {

        }
    }
);
queue.add(stringRequest);
queue.add(jsonObjectRequest);
```



## OKHttp

会从很多常用的连接问题中自动恢复，比如服务器配置了多个IP，当第一个IP连接失败时，会自动尝试下一个IP。

```java
okhttp3.Request.Builder requestBuilder = new okhttp3.Request.Builder().url("http://blog.csdn.net/itachi85");
//POST请求需要用FormBody封装请求的参数
requestBuilder.method("GET", null);
okhttp3.Request request = requestBuilder.build();

OkHttpClient okHttpClient = new OkHttpClient();
Call call = okHttpClient.newCall(request);

call.enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {

    }

    @Override
    public void onResponse(Call call, okhttp3.Response response) throws IOException {
        Log.d(TAG, "====" + response.body().toString());
    }
});
```

## Retrofit

底层是基于OkHttp实现的。

与其他框架不同的是，更多使用运行时注解的方式提供功能。

```java
//POST
public interface IpServiceForPost {
    @FormUrlEncoded
    @POST("{path}/getIpInfo.php")
    Call<IpModel> getIpMsg(@Path("path") String path, @Field("ip") String first);
}

//GET
public interface IpService {
    @GET("{path}/getIpInfo.php")
    Call<IpModel> getIpMsg(@Path("path") String path, @Query("ip") String ip);
}

//其他注解
//Path：地址
//Query(Map)
//Field
//Body 数据传输类型JSON字符串
//Part 单个文件上传
//Header 消息报头


String url = "http://ip.taobao.com/";
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl(url)
    .addConverterFactory(GsonConverterFactory.create())
    .build();
IpService ipService = retrofit.create(IpService.class);
retrofit2.Call<IpModel> call = ipService.getIpMsg("service","59.108.54.37");

// 同步方法使用execute
call.enqueue(new retrofit2.Callback<IpModel>() {
    @Override
    public void onResponse(retrofit2.Call<IpModel> call, retrofit2.Response<IpModel> response) {
        String country = response.body().toString();
        Log.d(TAG, "==== coutry is " + country);
    }

        @Override
        public void onFailure(retrofit2.Call<IpModel> call, Throwable t) {

        }
});
```