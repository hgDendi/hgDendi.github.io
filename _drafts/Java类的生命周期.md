# Java类的生命周期 #


## 重要内存区域 ##

- 方法区

>已经加载的类信息、常量、静态变量以及方法代码的内存区域
- 常量池

>常量和类中的符号引用
- 堆区

> 对象实例

- 栈区

>由一个一个的栈帧组成的栈式结构,栈帧包含:方法运行时产生的局部变量、方法出口等信息。

## 类的生命周期 ##

![Screen Shot 2017-01-16 at 20.38.17](/Users/dendich/Desktop/Screen Shot 2017-01-16 at 20.38.17.png)

### Loading 加载

>找到需要加载的类并把类的信息加载到方法区中，然后在堆区中实例化一个Class对象，作为方法区中这个类的信息的入口

1. 根据类的全名，生成一份二进制的字节码
2. 将字节码解析成方法区对应的数据结构
3. 生成Class对象的实例表示该类

### Linking 连接

不一定要等到加载完成后，有时可以**同时执行**（比如Loading和Verification可以同时执行）

#### Verification

保证类符合Java的语法规范。

比如：bytecode的完整性、final方法的检查、方法签名的检查

#### Preparation

JVM为类的成员变量分配内存空间并且赋予默认初始值，需要注意的是这个阶段不会执行任何代码，而**只是根据变量类型决定初始值**。即所有int赋值为0，代码中的初始化赋值不进行运行。

也可能会为有助于提高程序性能的数据结构分配内存，比如method table。

method table这个数据结构包含了只想所有类方法的指针（包括从父类集成的方法）

#### Resulotion

确认类、接口、属性和方法在类的**run-time constant pool**的位置，并且把这些符号引用替换为直接引用。

symbolic references ==》 direct reference



![Screen Shot 2017-01-16 at 20.55.10](/Users/dendich/Desktop/Screen Shot 2017-01-16 at 20.55.10.png)

### Initialization 初始化

>如果一个类被直接引用，就会触发类的初始化
>
- 通过new实例化、读取或设置类的静态变量、调用类的静态方法
- 通过反射方式执行上面三种方法
- 初始化子类时，会触发父类
- 程序入口直接运行时，调用main方法时


>其他引用为被动引用，不会触发初始化。

>只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行

### Using 使用

>讲一下类的被动引用
>
- 引用父类的静态字段，只会引起父类的初始化，不会引起子类的初始化
- 定义类数组，不会引起类的初始化
- 引用类的常量，不会引起类的初始化

#### Unloading 卸载

>满足下面的情况，类就会被卸载
>


- 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有任何地方呗引用，无法再任何地方通过反射访问该类的方法